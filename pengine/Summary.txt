★概要
  colocation A with Bの場合、必ず、B側のcolorから処理される
  よって
    colocation A with B
    colocation B with C
  の場合は、最初にCのcolorが処理される
  
  with側のcolor処理中に、左側(rsc側)のスコアもwith側にマージされる
   * 左側(rsc側)故障などによるwith側のcolor決定スコアへの反映
   * 全てのwith側が指定されているcolocationを手繰って、そのスコアもwith側のcolorスコアへ反映する

  with側のcolor処理完了後(配置先決定、配置先候補ノード情報のスコア決定)に、rsc側のcolor処理に戻って、with側のcolorで決定したスコアをrcs側にマージする
  全てのrsc側が指定されているcolocationを手繰って、そのスコアもwith側のcolorスコアへ反映する
  
　rsc側の配置先を決定する。

  Masterリソース、cloneリソースは、colorが処理されない間は、子リソースの配置先候補ノード情報にスコア(故障時などの-INFINITY)が反映されない。
   * 反映は、親リソースだけで子リソースはcolor時に反映

　よって、通常のnativeリソースをA、Master/cloneリソースをFとした場合

     A with F
  と
     F with A
　では、F故障時の動作が異なる。
  
  これは、with Fとした場合は、Fのcolor処理が済んでいる為、A側への配置ノード関連の反映が行われるが...
  with Aとした場合には、A側の配置ノード関連への反映は、まだ、F側のcolor処理が済んでいない(次の遷移roleが決まっていない場合)時は行われない....


 ●内部的に追加されるcolocationについて
   primitiveリソース	: なし
   groupリソース		: ordered=true(デフォルト)の場合、groupリソース内の子リソース間(前後関係でINF)のcolocationが追加される	group_internal_constraints()
   cloneリソース		: なし(内部の子リソース自体の追加処理は、必要があれば個別に処理される) 例:cloneの中にgroupがある場合など....
   masterリソース		: なし(内部の子リソース自体の追加処理は、必要があれば個別に処理される) 例:master/slaveの中にgroupがある場合など....

 ●color時の特殊なcolocation処理について
   primitiveリソース	: なし
   groupリソース		: groupリソースに付けられているcolocation(rsc指定、with-rsc指定)の情報は全て最初の子リソースにセットする。
						　そして、最初の子リソースにセットしたgroupリソース自体のcolocation情報は削除する。	group_color()
   cloneリソース		: clone_max値と起動ノード数によって処理が違う
						  clone_max指定があって起動ノード数が一致しない場合は、cloneリソースのcolocation情報(rsc指定、with-src指定）を子インスタンスにセットする
						  clone_max指定があって起動ノード数が一致する場合は、cloneリソースのcolocation情報(rsc指定のみ）を子インスタンスにセットする
                           * 負数とINFINITY設定のrsc指定がセットされる
　　　　　　　　　　　　　 * ただし、負数や-INFINITY設定のwith-rsc指定はセットされる
																											clone_color()
   masterリソース		: masterリソース自体は、cloneリソースのcolor時の処理を実行している為、cloneリソースと子インスタンスと同じcolocation情報がセットされる


1) colocationの例
  
   colocation A with B sore:INF の場合

   1-1) Bのcolorを先に処理
   	* 計算したBの配置先の候補ノード情報にAの配置先の候補ノード情報をマージする : colocationの反映
     * 例えば、Aリソースに故障が発生してAの配置先-INFで状態遷移が処理されれば、-INFがBにも反映される
   	* Bの配置先を決定 : allocated_toへ
   1-2) Aのcolor処理に戻る
    * 決定したBの配置先情報をAの配置先の候補ノード情報に反映する : colocationの反映
     * Bの配置先が決定した場合は、Aの配置先の候補ノード情報で一致しないノードには-INFINITYをマージ(Bで決まった配置先に従う)
     * Aの配置先を決定 : allocated_toへ


  例)初期起動
   ノード : node1, node2
   natvie : A, B
   location : B - node1 - score 200
   location : B - node1 - score 100
   colocation A with B sore:INF

   1) 初期location適用後
     A - node1:200
         node2:100
     B - node1:0
         node2:0
   2) Bのcolor処理
     B - node1:0+200*1 (colocationの反映: Aのスコアマージ)
         node2:0+*100*1 (colocationの反映: Aのスコアマージ)
         node1:allocated_to
   3) Aのcolor処理戻り
     A - node1:200
         node2:100
     --------------(colocationの反映)--------------------------------
     A - node1:200 (Bの配置先の候補ノード情報を反映するがスコアは加算されない)
         node2:100+(-INFINITY) (Bの配置先の候補ノード情報を反映するがスコアは加算されない.追い出しの-INFINITYだけが加算される)

     --------------(Bの決定した配置先の反映)--------------------------------
     A - node1:200
         node2:100+(-INFINITY)
         node1:allocated_to
   4)処理後
	native_color: resourceB allocation score on rh63-heartbeat1: 200 -配置
	native_color: resourceB allocation score on rh63-heartbeat2: 100
	native_color: resourceA allocation score on rh63-heartbeat1: 200 -配置
	native_color: resourceA allocation score on rh63-heartbeat2: -1000000


  例)Bの故障からの追い出し
   ノード : node1, node2
   natvie : A, B
   location : B - node1 - score 200
   location : B - node1 - score 100
   colocation A with B sore:INF

   1) 初期location適用後
     A - node1:200
         node2:100
     B - node1:0
         node2:0
   2) 起動情報適用後
     A - node1:INFINITY
         node2:100
     B - node1:INFINITY
         node2:0
   3) 故障location適用後
     A - node1:INFINITY
         node2:100
     B - node1:-INFINITY
         node2:0

   4) Bのcolor処理
     B - node1:-INFINITY + INFINITY * 1 (colocationの反映: Aのスコアマージ)
         node2:0 + 100 * 1(colocationの反映: Aのスコアマージ)
         node2:allocated_to
   5) Aのcolor処理戻り
     A - node1:INFINITY
         node2:100
     --------------(colocationの反映)--------------------------------
     A - node1:INFINITY + -INFINITY(Bの配置先の候補ノード情報を反映)
         node2:100
         node2:allocated_to

   4)処理後
	native_color: resourceB allocation score on rh63-heartbeat1: -1000000
	native_color: resourceB allocation score on rh63-heartbeat2: 100 - 配置
	native_color: resourceA allocation score on rh63-heartbeat1: -1000000
	native_color: resourceA allocation score on rh63-heartbeat2: 100 - 配置


  例)Aの故障からの追い出し
   ノード : node1, node2
   natvie : A, B
   location : B - node1 - score 200
   location : B - node1 - score 100
   colocation A with B sore:INF

   1) 初期location適用後
     A - node1:200
         node2:100
     B - node1:0
         node2:0
   2) 起動情報適用後
     A - node1:INFINITY
         node2:100
     B - node1:INFINITY
         node2:0
   3) 故障location適用後
     A - node1:-INFINITY
         node2:100
     B - node1:INFINITY
         node2:0

   4) Bのcolor処理
     B - node1:INFINITY + -INFINITY * 1 (colocationの反映: Aのスコアマージ)
         node2:0 + 100 * 1 (colocationの反映: Aのスコアマージ)
         node2:allocated_to
   5) Aのcolor処理戻り
     A - node1:-INFINITY
         node2:100
     --------------(colocationの反映)--------------------------------
     A - node1:-INFINITY + -INFINITY(Bの配置先の候補ノード情報を反映)
         node2:100
         node2:allocated_to

   4)処理後
	native_color: resourceB allocation score on rh63-heartbeat1: -1000000
	native_color: resourceB allocation score on rh63-heartbeat2: 100 - 配置
	native_color: resourceA allocation score on rh63-heartbeat1: -1000000
	native_color: resourceA allocation score on rh63-heartbeat2: 100 - 配置



★未整理メモ
 * 起動済み、故障検知のロケーション反映
  * 起動済みのリソースに関しては、stage2処理で
    リソース情報のrunnning_onリストに設定され、common_apply_stickiness()処理にて、"stickiness"ロケーションとして
    resource-stickiness値がセットされる
  * 故障検知のリソースもstage2処理で
　  "__fail_limit__"ロケーションとして、-INFINITY値がセットされる
  * 上記設定されたロケーションは、続く、stage2処理のapply_placement_constraint()処理にて、
    リソース情報の配置候補ノード情報リスト(allowed_nodes)のweightへ反映される
 * colocationのscore処理の違い
  * score = INFINITY設定時
　　with側の配置ノード情報へのcolocation反映時に、rsc側の配置候補ノード情報リストのスコアが反映(factor:1-係数で)される
     * 係数の計算だけに、INFINITY/INFINITY=1が利用される
    rsc側からのwith側のcolocation反映時は、with指定側の配置ノード(allocated_to)が決定していない場合か、with指定側の配置ノードでない
    ノードへの反映時に-INFINITY値(スコア値:-INFINITY*facttor:1)が反映される。
    よって、INFINITY設定時は、そのままINFINITY値がセットされることはない。(配置不可として-INFININTYは上記の通りあり)
  * INFINITY > sore > 0設定時
　　with側の配置ノード情報へのcolocation反映時に、rsc側の配置候補ノード情報リストのスコアが反映されない(factor:0-係数で)
    rsc側からのwith側のcolocation反映時は、そのままスコア値が反映される
    しかし、反映した結果配置先がないようであれば反映はキャンセルされる
　*－INFINITY設定時
    rsc側の配置ノード情報へのcolocation反映時に、with-rsc側の配置ノードが決定している場合は、with指定側の配置ノードでない
    ノードへの反映時に-INFINITY値(スコア値:-INFINITY)が反映される。（これにより、同一ノードでは配置できなくなる）
　　with-rsc側の配置ノードが決定していない場合は-INFINITYは反映しない。
    さらに以下のような場合は、
     
      colocation A with B sore:INF
      colocation B with C sore:-INF
      (この設定では、AとC間の関係も-INFになる)

    Bへの反映から、さらにAを手繰る時にも、AとC間の関係はマイナス値として処理するように内部でmultiplier値を持っている。

 * Master:role指定のcolocationが適用されない
   
   colocation A:Master with B score :INF

　 のようなcolocationがある場合、対象MasterリソースAがcolocationを適用した結果、配置先がなくなる場合にはcolocationが適用されない。
　 例えば、Master/Slave構成で単一Masterノード起動時などが該当する。
　 この場合、Bリソース故障によってAリソースは停止されずにそのまま保持されることになる。

　 該当処理は、以下の部分である(pengine/native.c)

  {{{
		/************************* このリソースに対するwith-rsc指定のリソースのcolorを先に処理する ***********************/
		/* このリソースのcolocation情報の依存するリソース(with-rsc)に対応するリソースをcolor処理を実行する */
		rsc_rh->cmds->color(rsc_rh, data_set);
		/* このリソースのrsc_colocation_lh処理でこのwith-rscリソースのcolocationのスコアを反映する */
		/* ※with-rsc指定されたリソースの配置先が決定している場合には、このリソースのweightにcolocationのスコアを反映する */
		rsc->cmds->rsc_colocation_lh(rsc, rsc_rh, constraint);	
		if(archive && can_run_any(rsc->allowed_nodes) == FALSE) {
			/* colocation情報のrole_lh(with-rscのrole)がRSC_ROLE_MASTER以上か、スコアがマイナス値で設定されていて（-INFINTY以外)、リソースの配置可能なノードがない場合 */
			/* with-rsc指定側の反映をキャンセルする */
		    crm_info("%s: Rolling back scores from %s", rsc->id, rsc_rh->id);
		    pe_free_shallow_adv(rsc->allowed_nodes, TRUE);
		    /* リソースのallowed_nodesリストにarchiveリストをセットする */
		    rsc->allowed_nodes = archive;
		    archive = NULL;
		}
		pe_free_shallow_adv(archive, TRUE);
	    );	
  }}}